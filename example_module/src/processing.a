_PROCESSING_ASM	 # Comment if we do not want assembler processing

	.if defined (_PROCESSING_ASM)
	.include "example_module_mcv.h"
	
_BLOCK_SIZE .equ 16
_L_CHANNEL .equ 0
_R_CHANNEL .equ 1
_C_CHANNEL .equ 2
_LFE_CHANNEL .equ 3
_LS_CHANNEL .equ 4
_RS_CHANNEL .equ 5

	.xdata_ovly

_HPF5kHz .dw (0.33063278670382765), (-0.66126557340765530), (0.33063278670382765), (0.5), (-0.58506847445620070), (0.23746267235911003) 
_LPF800Hz .dw  (0.00149685338594683095), (0.00299370677189366190), (0.00149685338594683095), (0.5), (-0.9195583986626017000), (0.42556417062298607000)

	.ydata_ovly
	
_x_historyLs	.bsc(2), (0)
_y_historyLs	.bsc(2), (0)
_x_historyLfe	.bsc(2), (0)
_y_historyLfe	.bsc(2), (0)
	
	.public _processing
	.public _second_order_IIR
	.extern _limiterThreshold
	.extern _stage_two_gain
#	.extern _variableGain
	.extern _mode
	.extern _variablesGain
	.extern example_module_MCV (MCV_T)
	
	.code_ovly
	
_second_order_IIR:
	#neoptimizovan
	# DSPaccum output = FRACT_NUM(0.0);
	# a0 input, i0 coeffs, i4 x_history, i5 y_history
	/*ymem[i7] = b3g; i7+=1										
	ymem[i7] = b3h; i7+=1										
	ymem[i7] = b3l; i7+=1			

	y0 = a0							

	x0 = xmem[i0]					
	uhalfword(b3) = (0)				
	
	b3 += x0 * y0
	i0+=1
	x0 = xmem[i0]
	y0 = ymem[i4]
	b3 += x0 * y0
	i0+=1
	i4+=1
	x0 = xmem[i0]
	y0 = ymem[i4]
	b3 += x0 * y0
	i0+=1
	i0+=1
	x0 = xmem[i0]
	y0 = ymem[i5]
	b3 -= x0 * y0
	i0+=1
	i5+=1
	x0 = xmem[i0]
	y0 = ymem[i5]
	b3 -= x0 * y0
	
	i5-=1
	y0 = ymem[i5]
	i5+=1
	i4-=1		

	b3 = b3 << 1					
	
	ymem[i5] = y0; i5-=1										
	ymem[i5] = b3;												
	y0 = ymem[i4]; i4+=1										
	ymem[i4] = y0; i4-=1										
	ymem[i4] = a0												
	
	AnyReg(a0l, b3l)											
	AnyReg(a0h, b3h)											
	AnyReg(a0g, b3g)				

	i7-=1
	b3l = ymem[i7]; i7-=1
	b3h = ymem[i7]; i7-=1
	b3g = ymem[i7]*/
	
	#optimizovan
	ymem[i7] = b3g; i7+=1										
	ymem[i7] = b3h; i7+=1										
	ymem[i7] = b3l; i7+=1										# Stavljamo na stek ono sto nije dostupno za upotrebu

	y0 = a0														# y0 = input
	# zakomentarisati i0+=1 za neoptimizovanu verziju
	x0 = xmem[i0]; i0+=1	# <-								# x0 = koeficijent
	uhalfword(b3) = (0)											# output = 0
	
	b3 += x0 * y0; x0 = xmem[i0]; i0+=1; y0 = ymem[i4]; i4+=1	
	b3 += x0 * y0; x0 = xmem[i0]; i0+=1; y0 = ymem[i4];	i4-=1	
	i0+=1
	b3 += x0 * y0; x0 = xmem[i0]; i0+=1; y0 = ymem[i5]; i5+=1	
	b3 -= x0 * y0; x0 = xmem[i0]; y0 = ymem[i5]; i5-=1			
	b3 -= x0 * y0; y0 = ymem[i5]; i5+=1		
	
	// ----------------------------				

	b3 = b3 << 1												# Shiftujemo zato sto su svi koeficijenti bili skalirani (>> 1)
	
	ymem[i5] = y0; i5-=1										
	ymem[i5] = b3;												
	y0 = ymem[i4]; i4+=1										
	ymem[i4] = y0; i4-=1										
	ymem[i4] = a0												
	
	AnyReg(a0l, b3l)											
	AnyReg(a0h, b3h)											
	AnyReg(a0g, b3g)											# prebacujemo b3 u a0 zato sto se u a0 mora nalaziti povratna vrednost

	i7-=1
	b3l = ymem[i7]; i7-=1
	b3h = ymem[i7]; i7-=1
	b3g = ymem[i7]
	ret
	
_processing:
# na raspolaganju a0 a1 b0 b1 i4 i5
	do(_BLOCK_SIZE), >loop
		#L channel
		# *p_L_channel_out = *p_L_channel_in * variableGain;
		i5 = i0 + (_L_CHANNEL * _BLOCK_SIZE)
		x0 = ymem[i5]
		y0 = xmem[example_module_MCV.G1]
		a0 = x0 * y0
		i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
		ymem[i5] = a0
		
		# LS is inverted
		# *p_LS_channel_out = -*p_L_channel_out;
		# rescaled = second_order_IIR((DSPaccum)*p_LS_channel_out, HPF5kHz, x_historyLs, y_historyLs);
		# *p_LS_channel_out = rescaled;
		# i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
		x0 = ymem[i5]	#iznad ovoga ces mozda morati opet adresu upisati u i5
		a0 = -x0		
		ymem[i7] = i0; i7+=1
		i0 = (_HPF5kHz)
		ymem[i7] = i4; i7+=1
		i4 = (_x_historyLs)
		ymem[i7] = i5; i7+=1 
		i5 = (_y_historyLs)
		call _second_order_IIR
		i7-=1
		i5 = ymem[i7]; i7-=1
		i4 = ymem[i7]; i7-=1
		i0 = ymem[i7] 
		
		#b1 = a0
		b0 = xmem[_limiterThreshold]
		if (b0 < a0) a0 = b0
		b0 = -b0
		if(b0 > a0) a0 = b0
		
		i5 = i1 + (_LS_CHANNEL * _BLOCK_SIZE)
		ymem[i5] = a0
		
		# R channel
		# *p_R_channel_out = *p_R_channel_in * variableGain;
		i5 = i0 + (_R_CHANNEL * _BLOCK_SIZE)
		x0 = ymem[i5]
		y0 = xmem[example_module_MCV.G1]
		a0 = x0 * y0
		i5 = i1 + (_R_CHANNEL * _BLOCK_SIZE)
		ymem[i5] = a0
		
		# RS is inverted
		# *p_RS_channel_out = -*p_R_channel_out;
		x0 = ymem[i5]
		a0 = -x0
		i5 = i1 + (_RS_CHANNEL * _BLOCK_SIZE)
		ymem[i5] = a0
		
		# if mode == 3_2_1 == 3
		a0 = xmem[_mode]
		b0 = (0)
        uhalfword(b0h) = (0x3)
        a0 - b0
        if (a != 0) jmp>end

%mode_3_2_0:					
			# Central channel is L+R
			i5 = i1 + (_R_CHANNEL * _BLOCK_SIZE)
			x0 = ymem[i5]
			a0 = x0
			a0 = a0 >> 1
			a0 = a0 >> 1
			x0 = a0
			y0 = xmem[example_module_MCV.G2]
			a0 = x0 * y0	#scaledR
			
			i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
			x0 = ymem[i5]
			a1 = x0
			a1 = a1 >> 1
			a1 = a1 >> 1
			x0 = a1
			y0 = xmem[example_module_MCV.G2]
			a1 = x0 * y0	#scaledL
			
			a0 = a1 + a0
			a0 = a0 << 1
			a0 = a0 << 1
			
			#a1 = xmem[_limiterThreshold]
			#a0 - a1
			#if (a < 0) jmp>checkFmin
			#	a0 = a1
#%checkFmin:
#			a1 = -a1
#			a0 - a1
#			if (a >= 0) jmp>saturated
#				a0 = a1
#%saturated:
			b0 = xmem[_limiterThreshold]
			if (b0 < a0) a0 = b0  
			b0 = -b0
			if (b0 > a0) a0 = b0
			
			i5 = i1 + (_C_CHANNEL * _BLOCK_SIZE)
			ymem[i5] = a0
			# if mode == 3_2_0 == 2
			a0 = xmem[_mode]
			b0 = (0)
        	uhalfword(b0h) = (0x2)
        	a0 - b0
        	if (a == 0) jmp>endEnd
			
%mode_2_2_1:

			# Central channel is L-R
			i5 = i1 + (_R_CHANNEL * _BLOCK_SIZE)
			x0 = ymem[i5]
			a0 = x0
			a0 = a0 >> 1
			a0 = a0 >> 1
			x0 = a0
			y0 = xmem[example_module_MCV.G2]
			a0 = x0 * y0	#scaledR
			
			i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
			x0 = ymem[i5]
			a1 = x0
			a1 = a1 >> 1
			a1 = a1 >> 1
			x0 = a1
			y0 = xmem[example_module_MCV.G2]
			a1 = x0 * y0	#scaledL
			
			a0 = a1 - a0
			a0 = a0 << 1
			a0 = a0 << 1
			
			b0 = xmem[_limiterThreshold]
			#a0 - a1
			if (b0 < a0) a0 = b0  #jmp>checkFmin
			b0 = -b0
			if (b0 > a0) a0 = b0
#%checkFmin:
			#a1 = -a1
			#a0 - a1
			#if (a >= 0) jmp>saturated
				#a0 = a1
#%saturated:
			ymem[i7] = i0; i7+=1
			i0 = (_LPF800Hz)
			ymem[i7] = i4; i7+=1
			i4 = (_x_historyLfe)
			ymem[i7] = i5; i7+=1 
			i5 = (_y_historyLfe)
			call _second_order_IIR
			i7-=1
			i5 = ymem[i7]; i7-=1
			i4 = ymem[i7]; i7-=1
			i0 = ymem[i7] 
			
			#b1 = a0
			b0 = xmem[_limiterThreshold]
			if (b0 < a0) a0 = b0
			b0 = -b0
			if(b0 > a0) a0 = b0
				
			i5 = i1 + (_LFE_CHANNEL * _BLOCK_SIZE)
			ymem[i5] = a0
			
			# if mode == 2_2_1 == 1
			a0 = xmem[_mode]
			b0 = (0)
	        uhalfword(b0h) = (0x1)
	        a0 - b0
	        if (a == 0) jmp>endEnd
		
%end:
		# if mode == 3_2_0 == 2
		a0 = xmem[_mode]
		b0 = (0)
        uhalfword(b0h) = (0x2)
        a0 - b0
        if (a == 0) jmp<mode_3_2_0
        	# if mode == 2_2_1 == 1
			a0 = xmem[_mode]
			b0 = (0)
	        uhalfword(b0h) = (0x1)
	        a0 - b0
	        if (a == 0) jmp<mode_2_2_1
%endEnd:	
		
		i0+=1
%loop:	i1+=1

	ret
	
	.endif