1     	 0000				_PROCESSING_ASM	 # Comment if we do not want assembler processing
2     						
3     							.if defined (_PROCESSING_ASM)
4     						.include "example_module_mcv.h"
4      >> open include file: D:/CirrusDSP/clide/workspace/example_module/gen/inc/example_module_mcv.h
1+    						/*
2+    						 * This file is automatically generated by CLIDE
3+    						 *
4+    						 * MCV (Module Control Vector)
5+    						 */
6+    						.include "dsplib/meter_asm.h" 
6+     >> open include file: D:/CirrusDSP/include/dsplib/meter_asm.h
1+    							.if !defined(_meter_h_)
2+    	 0000				_meter_h_
3+    						
4+    						METER_T .struct
5+    						RMS .dw 0			#fract(1.31)
6+    						RMS_HOLD .dw 0		#fract(1.31)
7+    						PEAK .dw 0			#fract(1.31)
8+    						PEAK_HOLD .dw 0		#fract(1.31)
9+    							.endstruct
10+   						
11+   						(null)11+    >> end of include file: D:/CirrusDSP/include/dsplib/meter_asm.h
11+    >> continuing with file: D:/CirrusDSP/clide/workspace/example_module/gen/inc/example_module_mcv.h
7+    						.include "dsplib/response_asm.h"
7+     >> open include file: D:/CirrusDSP/include/dsplib/response_asm.h
1+    							.if !defined(_response_h_)
2+    	 0000				_response_h_
3+    						
4+    						BIQUAD_T .struct
5+    						COEF_A1 .dw 0			#fract(2.30)
6+    						COEF_A2 .dw 0			#fract(2.30)
7+    						COEF_B0 .dw 1			#fract(3.29)
8+    						COEF_B1 .dw 0			#fract(3.29)
9+    						COEF_B2 .dw 0			#fract(3.29)
10+   							.endstruct
11+   						
12+   						RESPONSE_T .struct
13+   						PRE .dw 0			#fract(7.25)
14+   						POST .dw 0			#fract(7.25)
15+   							.rept %i = 0,2
16+   						BIQUAD_%i BIQUAD_T		#struct
17+    >> start of macro: .rept
1+    						BIQUAD_0 BIQUAD_T		#struct
2+    						BIQUAD_1 BIQUAD_T		#struct
3+    						BIQUAD_2 BIQUAD_T		#struct
4+    						
17+   							.endm
18+   							.endstruct
19+   							
20+   							.endif21+   						(null)21+    >> end of include file: D:/CirrusDSP/include/dsplib/response_asm.h
21+    >> continuing with file: D:/CirrusDSP/clide/workspace/example_module/gen/inc/example_module_mcv.h
8+    						
9+    	 0001				isDefined	 .equ 	 1
10+   						
11+   						MCV_T	.struct
12+   						enable .dw 0	 # bool	non-zero to enable this function
13+   						G1 .dw 0	 #fract(1.31)
14+   						G2 .dw 0	 #fract(1.31)
15+   							.endstruct
16+   						
17+   						
18+   	 0000				STRUCTURE_INITIALIZATION_STRNG .equ "0x1, 0x00000000, 0x00000000"
19+    >> end of include file: D:/CirrusDSP/clide/workspace/example_module/gen/inc/example_module_mcv.h
19+    >> continuing with file: D:/CirrusDSP/clide/workspace/example_module/src/processing.a
5     							
6     	 0010				_BLOCK_SIZE .equ 16
7     	 0000				_L_CHANNEL .equ 0
8     	 0001				_R_CHANNEL .equ 1
9     	 0002				_C_CHANNEL .equ 2
10    	 0003				_LFE_CHANNEL .equ 3
11    	 0004				_LS_CHANNEL .equ 4
12    	 0005				_RS_CHANNEL .equ 5
13    						
14    							.xdata_ovly
14     >> start of macro: .xdata_ovly
1+    									seg_single , "X_OVLY", X
1+     >> start of macro: seg_single
1+    						  .if ( "" != "" ) & defined( ___SegStart_X_ )
2+    						    segment
3+    						  .else
4+    						    segment "X_OVLY"
5+    							.if "" != ""
6+    						___SegStart_X_
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .xdata_ovly
15    						
16    	 0000				_HPF5kHz .dw (0.33063278670382765), (-0.66126557340765530), (0.33063278670382765), (0.5), (-0.58506847445620070), (0.23746267235911003) 
	 0000	 2A522CD7	 
	 0001	 AB5BA652	 
	 0002	 2A522CD7	 
	 0003	 40000000	 
	 0004	 B51C79EA	 
	 0005	 1E652D46	 
17    	 0006				_LPF800Hz .dw  (0.00149685338594683095), (0.00299370677189366190), (0.00149685338594683095), (0.5), (-0.9195583986626017000), (0.42556417062298607000)
	 0006	 00310C84	 
	 0007	 00621908	 
	 0008	 00310C84	 
	 0009	 40000000	 
	 000A	 8A4BE90F	 
	 000B	 3678E302	 
18    						
19    							.ydata_ovly
19     >> start of macro: .ydata_ovly
1+    									seg_single , "Y_OVLY", Y
1+     >> start of macro: seg_single
1+    						  .if ( "" != "" ) & defined( ___SegStart_Y_ )
2+    						    segment
3+    						  .else
4+    						    segment "Y_OVLY"
5+    							.if "" != ""
6+    						___SegStart_Y_
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .ydata_ovly
20    							
21    	 0000				_x_historyLs	.bsc(2), (0)
	 0000	 00000000	 
	 0001	 00000000	 
22    	 0002				_y_historyLs	.bsc(2), (0)
	 0002	 00000000	 
	 0003	 00000000	 
23    	 0004				_x_historyLfe	.bsc(2), (0)
	 0004	 00000000	 
	 0005	 00000000	 
24    	 0006				_y_historyLfe	.bsc(2), (0)
	 0006	 00000000	 
	 0007	 00000000	 
25    							
26    	 0000					.public _processing
27    	 0000					.public _second_order_IIR
28    	 0000					.extern _limiterThreshold
29    	 0000					.extern _stage_two_gain
30    						#	.extern _variableGain
31    	 0000					.extern _mode
32    	 0000					.extern _variablesGain
33    	 0000					.extern example_module_MCV (MCV_T)
34    							
35    							.code_ovly
35     >> start of macro: .code_ovly
1+    									seg_single , "CODE_OVLY", CODE
1+     >> start of macro: seg_single
1+    						  .if ( "" != "" ) & defined( ___SegStart_CODE_ )
2+    						    segment
3+    						  .else
4+    						    segment "CODE_OVLY"
5+    							.if "" != ""
6+    						___SegStart_CODE_
7+    							.endif
8+    						  .endif
9+    							#RememberSegmentType
10+    >> end of macro: seg_single
2+     >> end of macro: .code_ovly
36    							
37    	 0000				_second_order_IIR:
38    							# DSPaccum output = FRACT_NUM(0.0);
39    							# a0 input, i0 coeffs, i4 x_history, i5 y_history
40    							/*ymem[i7] = b3g; i7+=1										
41    							ymem[i7] = b3h; i7+=1										
42    							ymem[i7] = b3l; i7+=1			
43    						
44    							y0 = a0							
45    						
46    							x0 = xmem[i0]					
47    							uhalfword(b3) = (0)				
48    							
49    							b3 += x0 * y0
50    							i0+=1
51    							x0 = xmem[i0]
52    							y0 = ymem[i4]
53    							b3 += x0 * y0
54    							i0+=1
55    							i4+=1
56    							x0 = xmem[i0]
57    							y0 = ymem[i4]
58    							b3 += x0 * y0
59    							i0+=1
60    							i0+=1
61    							x0 = xmem[i0]
62    							y0 = ymem[i5]
63    							b3 -= x0 * y0
64    							i0+=1
65    							i5+=1
66    							x0 = xmem[i0]
67    							y0 = ymem[i5]
68    							b3 -= x0 * y0
69    							
70    							i5-=1
71    							y0 = ymem[i5]
72    							i5+=1
73    							i4-=1		
74    						
75    							b3 = b3 << 1					
76    							
77    							ymem[i5] = y0; i5-=1										
78    							ymem[i5] = b3;												
79    							y0 = ymem[i4]; i4+=1										
80    							ymem[i4] = y0; i4-=1										
81    							ymem[i4] = a0												
82    							
83    							AnyReg(a0l, b3l)											
84    							AnyReg(a0h, b3h)											
85    							AnyReg(a0g, b3g)				
86    						
87    							i7-=1
88    							b3l = ymem[i7]; i7-=1
89    							b3h = ymem[i7]; i7-=1
90    							b3g = ymem[i7]*/
91    							
92    	 0000	 A7D40017		ymem[i7] = b3g; i7+=1										
93    	 0001	 9FD40017		ymem[i7] = b3h; i7+=1										
94    	 0002	 97D40017		ymem[i7] = b3l; i7+=1										# Stavljamo na stek ono sto nije dostupno za upotrebu
95    						
96    	 0003	 48447FFF		y0 = a0														# y0 = input
97    							# zakomentarisati i0+=1 za neoptimizovanu verziju
98    	 0004	 80140010		x0 = xmem[i0]; i0+=1	# <-								# x0 = koeficijent
99    	 0005	 8F4A0000		uhalfword(b3) = (0)											# output = 0
100   							
101   	 0006	 0888240F		b3 += x0 * y0; x0 = xmem[i0]; i0+=1; y0 = ymem[i4]; i4+=1	
102   	 0007	 0890240F		b3 += x0 * y0; x0 = xmem[i0]; i0+=1; y0 = ymem[i4];	i4-=1	
103   	 0008	 02087FFF		i0+=1
104   	 0009	 08A8240F		b3 += x0 * y0; x0 = xmem[i0]; i0+=1; y0 = ymem[i5]; i5+=1	
105   	 000A	 00B0241F		b3 -= x0 * y0; x0 = xmem[i0]; y0 = ymem[i5]; i5-=1			
106   	 000B	 244D241F		b3 -= x0 * y0; y0 = ymem[i5]; i5+=1		
107   							
108   							// ----------------------------				
109   						
110   	 000C	 00004E07		b3 = b3 << 1												# Shiftujemo zato sto su svi koeficijenti bili skalirani (>> 1)
111   							
112   	 000D	 84D40025		ymem[i5] = y0; i5-=1										
113   	 000E	 8FD40005		ymem[i5] = b3;												
114   	 000F	 84940014		y0 = ymem[i4]; i4+=1										
115   	 0010	 84D40024		ymem[i4] = y0; i4-=1										
116   	 0011	 88D40004		ymem[i4] = a0												
117   							
118   	 0012	 97090010		AnyReg(a0l, b3l)											
119   	 0013	 9F090018		AnyReg(a0h, b3h)											
120   	 0014	 A7090020		AnyReg(a0g, b3g)											# prebacujemo b3 u a0 zato sto se u a0 mora nalaziti povratna vrednost
121   						
122   	 0015	 02177FFF		i7-=1
123   	 0016	 97940027		b3l = ymem[i7]; i7-=1
124   	 0017	 9F940027		b3h = ymem[i7]; i7-=1
125   	 0018	 A7940007		b3g = ymem[i7]
126   	 0019	 81880000		ret
127   							
128   	 001A				_processing:
129   						# na raspolaganju a0 a1 b0 b1 i4 i5
130   	 001A	 81000099		do(_BLOCK_SIZE), >loop
131   								#L channel
132   								# *p_L_channel_out = *p_L_channel_in * variableGain;
133   	 001B	 85050000			i5 = i0 + (_L_CHANNEL * _BLOCK_SIZE)
134   	 001C	 80940005			x0 = ymem[i5]
135   	 001D	 84040000			y0 = xmem[example_module_MCV.G1]
136   	 001E	 00002400			a0 = x0 * y0
137   	 001F	 85150000			i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
138   	 0020	 88D40005			ymem[i5] = a0
139   								
140   								# LS is inverted
141   								# *p_LS_channel_out = -*p_L_channel_out;
142   								# rescaled = second_order_IIR((DSPaccum)*p_LS_channel_out, HPF5kHz, x_historyLs, y_historyLs);
143   								# *p_LS_channel_out = rescaled;
144   								# i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
145   	 0021	 80940005			x0 = ymem[i5]	#iznad ovoga ces mozda morati opet adresu upisati u i5
146   	 0022	 00002810			a0 = -x0		
147   	 0023	 B0D40017			ymem[i7] = i0; i7+=1
148   	 0024	 B04A0000			i0 = (_HPF5kHz)
149   	 0025	 B8D40017			ymem[i7] = i4; i7+=1
150   	 0026	 B84A0000			i4 = (_x_historyLs)
151   	 0027	 B9D40017			ymem[i7] = i5; i7+=1 
152   	 0028	 B94A0002			i5 = (_y_historyLs)
153   	 0029	 80880000			call _second_order_IIR
154   	 002A	 02177FFF			i7-=1
155   	 002B	 B9940027			i5 = ymem[i7]; i7-=1
156   	 002C	 B8940027			i4 = ymem[i7]; i7-=1
157   	 002D	 B0940007			i0 = ymem[i7] 
158   								
159   								#b1 = a0
160   	 002E	 8C040000			b0 = xmem[_limiterThreshold]
161   	 002F	 00004860			if (b0 < a0) a0 = b0
162   	 0030	 00004C84			b0 = -b0
163   	 0031	 00004820			if(b0 > a0) a0 = b0
164   								
165   	 0032	 85150040			i5 = i1 + (_LS_CHANNEL * _BLOCK_SIZE)
166   	 0033	 88D40005			ymem[i5] = a0
167   								
168   								# R channel
169   								# *p_R_channel_out = *p_R_channel_in * variableGain;
170   	 0034	 85050010			i5 = i0 + (_R_CHANNEL * _BLOCK_SIZE)
171   	 0035	 80940005			x0 = ymem[i5]
172   	 0036	 84040000			y0 = xmem[example_module_MCV.G1]
173   	 0037	 00002400			a0 = x0 * y0
174   	 0038	 85150010			i5 = i1 + (_R_CHANNEL * _BLOCK_SIZE)
175   	 0039	 88D40005			ymem[i5] = a0
176   								
177   								# RS is inverted
178   								# *p_RS_channel_out = -*p_R_channel_out;
179   	 003A	 80940005			x0 = ymem[i5]
180   	 003B	 00002810			a0 = -x0
181   	 003C	 85150050			i5 = i1 + (_RS_CHANNEL * _BLOCK_SIZE)
182   	 003D	 88D40005			ymem[i5] = a0
183   								
184   								# if mode == 3_2_1 == 3
185   	 003E	 88040000			a0 = xmem[_mode]
186   	 003F	 8C7A0000			b0 = (0)
187   	 0040	 9C4A0003	        uhalfword(b0h) = (0x3)
188   	 0041	 00004F20	        a0 - b0
189   	 0042	 8448008E	        if (a != 0) jmp>end
190   						
191   	 0043				%mode_3_2_0:					
192   									# Central channel is L+R
193   	 0043	 85150010				i5 = i1 + (_R_CHANNEL * _BLOCK_SIZE)
194   	 0044	 80940005				x0 = ymem[i5]
195   	 0045	 40487FFF				a0 = x0
196   	 0046	 00004E40				a0 = a0 >> 1
197   	 0047	 00004E40				a0 = a0 >> 1
198   	 0048	 48407FFF				x0 = a0
199   	 0049	 84040000				y0 = xmem[example_module_MCV.G2]
200   	 004A	 00002400				a0 = x0 * y0	#scaledR
201   									
202   	 004B	 85150000				i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
203   	 004C	 80940005				x0 = ymem[i5]
204   	 004D	 40497FFF				a1 = x0
205   	 004E	 00004E41				a1 = a1 >> 1
206   	 004F	 00004E41				a1 = a1 >> 1
207   	 0050	 49407FFF				x0 = a1
208   	 0051	 84040000				y0 = xmem[example_module_MCV.G2]
209   	 0052	 00002401				a1 = x0 * y0	#scaledL
210   									
211   	 0053	 00004480				a0 = a1 + a0
212   	 0054	 00004E00				a0 = a0 << 1
213   	 0055	 00004E00				a0 = a0 << 1
214   									
215   									#a1 = xmem[_limiterThreshold]
216   									#a0 - a1
217   									#if (a < 0) jmp>checkFmin
218   									#	a0 = a1
219   						#%checkFmin:
220   						#			a1 = -a1
221   						#			a0 - a1
222   						#			if (a >= 0) jmp>saturated
223   						#				a0 = a1
224   						#%saturated:
225   	 0056	 8C040000				b0 = xmem[_limiterThreshold]
226   	 0057	 00004860				if (b0 < a0) a0 = b0  
227   	 0058	 00004C84				b0 = -b0
228   	 0059	 00004820				if (b0 > a0) a0 = b0
229   									
230   	 005A	 85150020				i5 = i1 + (_C_CHANNEL * _BLOCK_SIZE)
231   	 005B	 88D40005				ymem[i5] = a0
232   									# if mode == 3_2_0 == 2
233   	 005C	 88040000				a0 = xmem[_mode]
234   	 005D	 8C7A0000				b0 = (0)
235   	 005E	 9C4A0002	        	uhalfword(b0h) = (0x2)
236   	 005F	 00004F20	        	a0 - b0
237   	 0060	 84080098	        	if (a == 0) jmp>endEnd
238   									
239   	 0061				%mode_2_2_1:
240   						
241   									# Central channel is L-R
242   	 0061	 85150010				i5 = i1 + (_R_CHANNEL * _BLOCK_SIZE)
243   	 0062	 80940005				x0 = ymem[i5]
244   	 0063	 40487FFF				a0 = x0
245   	 0064	 00004E40				a0 = a0 >> 1
246   	 0065	 00004E40				a0 = a0 >> 1
247   	 0066	 48407FFF				x0 = a0
248   	 0067	 84040000				y0 = xmem[example_module_MCV.G2]
249   	 0068	 00002400				a0 = x0 * y0	#scaledR
250   									
251   	 0069	 85150000				i5 = i1 + (_L_CHANNEL * _BLOCK_SIZE)
252   	 006A	 80940005				x0 = ymem[i5]
253   	 006B	 40497FFF				a1 = x0
254   	 006C	 00004E41				a1 = a1 >> 1
255   	 006D	 00004E41				a1 = a1 >> 1
256   	 006E	 49407FFF				x0 = a1
257   	 006F	 84040000				y0 = xmem[example_module_MCV.G2]
258   	 0070	 00002401				a1 = x0 * y0	#scaledL
259   									
260   	 0071	 000044C0				a0 = a1 - a0
261   	 0072	 00004E00				a0 = a0 << 1
262   	 0073	 00004E00				a0 = a0 << 1
263   									
264   	 0074	 8C040000				b0 = xmem[_limiterThreshold]
265   									#a0 - a1
266   	 0075	 00004860				if (b0 < a0) a0 = b0  #jmp>checkFmin
267   	 0076	 00004C84				b0 = -b0
268   	 0077	 00004820				if (b0 > a0) a0 = b0
269   						#%checkFmin:
270   									#a1 = -a1
271   									#a0 - a1
272   									#if (a >= 0) jmp>saturated
273   										#a0 = a1
274   						#%saturated:
275   	 0078	 B0D40017				ymem[i7] = i0; i7+=1
276   	 0079	 B04A0006				i0 = (_LPF800Hz)
277   	 007A	 B8D40017				ymem[i7] = i4; i7+=1
278   	 007B	 B84A0004				i4 = (_x_historyLfe)
279   	 007C	 B9D40017				ymem[i7] = i5; i7+=1 
280   	 007D	 B94A0006				i5 = (_y_historyLfe)
281   	 007E	 80880000				call _second_order_IIR
282   	 007F	 02177FFF				i7-=1
283   	 0080	 B9940027				i5 = ymem[i7]; i7-=1
284   	 0081	 B8940027				i4 = ymem[i7]; i7-=1
285   	 0082	 B0940007				i0 = ymem[i7] 
286   									
287   									#b1 = a0
288   	 0083	 8C040000				b0 = xmem[_limiterThreshold]
289   	 0084	 00004860				if (b0 < a0) a0 = b0
290   	 0085	 00004C84				b0 = -b0
291   	 0086	 00004820				if(b0 > a0) a0 = b0
292   										
293   	 0087	 85150030				i5 = i1 + (_LFE_CHANNEL * _BLOCK_SIZE)
294   	 0088	 88D40005				ymem[i5] = a0
295   									
296   									# if mode == 2_2_1 == 1
297   	 0089	 88040000				a0 = xmem[_mode]
298   	 008A	 8C7A0000				b0 = (0)
299   	 008B	 9C4A0001		        uhalfword(b0h) = (0x1)
300   	 008C	 00004F20		        a0 - b0
301   	 008D	 84080098		        if (a == 0) jmp>endEnd
302   								
303   	 008E				%end:
304   								# if mode == 3_2_0 == 2
305   	 008E	 88040000			a0 = xmem[_mode]
306   	 008F	 8C7A0000			b0 = (0)
307   	 0090	 9C4A0002	        uhalfword(b0h) = (0x2)
308   	 0091	 00004F20	        a0 - b0
309   	 0092	 84080043	        if (a == 0) jmp<mode_3_2_0
310   						        	# if mode == 2_2_1 == 1
311   	 0093	 88040000				a0 = xmem[_mode]
312   	 0094	 8C7A0000				b0 = (0)
313   	 0095	 9C4A0001		        uhalfword(b0h) = (0x1)
314   	 0096	 00004F20		        a0 - b0
315   	 0097	 84080061		        if (a == 0) jmp<mode_2_2_1
316   	 0098				%endEnd:	
317   								
318   	 0098	 02087FFF			i0+=1
319   	 0099	 02097FFF	%loop:	i1+=1
320   						
321   	 009A	 81880000		ret
322   							
323   							.endif
				 SYMBOL TABLE 

    Name                                                                                    Type                  Value 

STRUCTURE_INITIALIZATION_STRNG                                                  			  Unused String		   '0x1, 0x00000000, 0x00000000' 
_BLOCK_SIZE                                                                     					 Number				          16 (10H)
_COMMON_INC_PATH_                                                               					 Define                 "D:/CirrusDSP/crystal32/common/inc/"
_C_CHANNEL                                                                      					 Number				          2 (2H)
_DSP_                                                                           			  Unused Variable		        0 (0H)
_HPF5kHz                                                                        			         Relocatable         processing_GEN_0000:0000H
_LFE_CHANNEL                                                                    					 Number				          3 (3H)
_LOCAL_INC_PATH_                                                                					 Define                 "inc/"
_LOCAL_SRC_PATH_                                                                					 Define                 "src/"
_LPF800Hz                                                                       			         Relocatable         processing_GEN_0000:0006H
_LS_CHANNEL                                                                     					 Number				          4 (4H)
_L_CHANNEL                                                                      					 Number				         0 (0H)
_PROCESSING_ASM                                                                 			  Unused Relocatable        __INIT:0000H
_ROUTER_INC_PATH_                                                               					 Define                 "rom_inc/"
_RS_CHANNEL                                                                     					 Number				          5 (5H)
_R_CHANNEL                                                                      					 Number				          1 (1H)
__CASM_VER__                                                                    			  Unused Variable		        0 (701H)
_limiterThreshold                                                               					 External   
_meter_h_                                                                       			  Unused Relocatable        __INIT:0000H
_mode                                                                           					 External   
_processing                                                                     			  Public Relocatable       processing_GEN_0002:001AH
_response_h_                                                                    			  Unused Relocatable        __INIT:0000H
_second_order_IIR                                                               			  Public Relocatable       processing_GEN_0002:0000H
_stage_two_gain                                                                 					 External   
_variablesGain                                                                  					 External   
_x_historyLfe                                                                   			         Relocatable         processing_GEN_0001:0004H
_x_historyLs                                                                    			         Relocatable         processing_GEN_0001:0000H
_y_historyLfe                                                                   			         Relocatable         processing_GEN_0001:0006H
_y_historyLs                                                                    			         Relocatable         processing_GEN_0001:0002H
example_module_MCV                                                              					 External   
isDefined                                                                       			  Unused Number				      1 (1H)

	       SEGMENTS:

Size			  Name										 Class
0000H	 __INIT                                  			 CODE                                    
000CH	 processing_GEN_0000                     			 X_OVLY                                  
0008H	 processing_GEN_0001                     			 Y_OVLY                                  
009BH	 processing_GEN_0002                     			 CODE_OVLY                               
